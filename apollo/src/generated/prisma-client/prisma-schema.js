module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCoachFeedback {
  count: Int!
}

type AggregateFeedbackEntry {
  count: Int!
}

type AggregateIQJobInfo {
  count: Int!
}

type AggregateJob {
  count: Int!
}

type AggregateListingAvailability {
  count: Int!
}

type AggregateListingIndustry {
  count: Int!
}

type AggregateListingTag {
  count: Int!
}

type AggregateSeekerReview {
  count: Int!
}

type AggregateSeekerReviewResponse {
  count: Int!
}

type AggregateServiceListing {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type CoachFeedback {
  id: ID!
  coach: User!
  seeker: User!
  job: Job!
  feedback(where: FeedbackEntryWhereInput, orderBy: FeedbackEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FeedbackEntry!]
  isSent: Boolean
}

type CoachFeedbackConnection {
  pageInfo: PageInfo!
  edges: [CoachFeedbackEdge]!
  aggregate: AggregateCoachFeedback!
}

input CoachFeedbackCreateInput {
  id: ID
  coach: UserCreateOneInput!
  seeker: UserCreateOneInput!
  job: JobCreateOneInput!
  feedback: FeedbackEntryCreateManyWithoutCoachFeedbackInput
  isSent: Boolean
}

input CoachFeedbackCreateOneWithoutFeedbackInput {
  create: CoachFeedbackCreateWithoutFeedbackInput
  connect: CoachFeedbackWhereUniqueInput
}

input CoachFeedbackCreateWithoutFeedbackInput {
  id: ID
  coach: UserCreateOneInput!
  seeker: UserCreateOneInput!
  job: JobCreateOneInput!
  isSent: Boolean
}

type CoachFeedbackEdge {
  node: CoachFeedback!
  cursor: String!
}

enum CoachFeedbackOrderByInput {
  id_ASC
  id_DESC
  isSent_ASC
  isSent_DESC
}

type CoachFeedbackPreviousValues {
  id: ID!
  isSent: Boolean
}

type CoachFeedbackSubscriptionPayload {
  mutation: MutationType!
  node: CoachFeedback
  updatedFields: [String!]
  previousValues: CoachFeedbackPreviousValues
}

input CoachFeedbackSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CoachFeedbackWhereInput
  AND: [CoachFeedbackSubscriptionWhereInput!]
  OR: [CoachFeedbackSubscriptionWhereInput!]
  NOT: [CoachFeedbackSubscriptionWhereInput!]
}

input CoachFeedbackUpdateInput {
  coach: UserUpdateOneRequiredInput
  seeker: UserUpdateOneRequiredInput
  job: JobUpdateOneRequiredInput
  feedback: FeedbackEntryUpdateManyWithoutCoachFeedbackInput
  isSent: Boolean
}

input CoachFeedbackUpdateManyMutationInput {
  isSent: Boolean
}

input CoachFeedbackUpdateOneRequiredWithoutFeedbackInput {
  create: CoachFeedbackCreateWithoutFeedbackInput
  update: CoachFeedbackUpdateWithoutFeedbackDataInput
  upsert: CoachFeedbackUpsertWithoutFeedbackInput
  connect: CoachFeedbackWhereUniqueInput
}

input CoachFeedbackUpdateWithoutFeedbackDataInput {
  coach: UserUpdateOneRequiredInput
  seeker: UserUpdateOneRequiredInput
  job: JobUpdateOneRequiredInput
  isSent: Boolean
}

input CoachFeedbackUpsertWithoutFeedbackInput {
  update: CoachFeedbackUpdateWithoutFeedbackDataInput!
  create: CoachFeedbackCreateWithoutFeedbackInput!
}

input CoachFeedbackWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  coach: UserWhereInput
  seeker: UserWhereInput
  job: JobWhereInput
  feedback_every: FeedbackEntryWhereInput
  feedback_some: FeedbackEntryWhereInput
  feedback_none: FeedbackEntryWhereInput
  isSent: Boolean
  isSent_not: Boolean
  AND: [CoachFeedbackWhereInput!]
  OR: [CoachFeedbackWhereInput!]
  NOT: [CoachFeedbackWhereInput!]
}

input CoachFeedbackWhereUniqueInput {
  id: ID
}

scalar DateTime

type FeedbackEntry {
  id: ID!
  CoachFeedback: CoachFeedback!
  title: String!
  content: String!
}

type FeedbackEntryConnection {
  pageInfo: PageInfo!
  edges: [FeedbackEntryEdge]!
  aggregate: AggregateFeedbackEntry!
}

input FeedbackEntryCreateInput {
  id: ID
  CoachFeedback: CoachFeedbackCreateOneWithoutFeedbackInput!
  title: String!
  content: String!
}

input FeedbackEntryCreateManyWithoutCoachFeedbackInput {
  create: [FeedbackEntryCreateWithoutCoachFeedbackInput!]
  connect: [FeedbackEntryWhereUniqueInput!]
}

input FeedbackEntryCreateWithoutCoachFeedbackInput {
  id: ID
  title: String!
  content: String!
}

type FeedbackEntryEdge {
  node: FeedbackEntry!
  cursor: String!
}

enum FeedbackEntryOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
}

type FeedbackEntryPreviousValues {
  id: ID!
  title: String!
  content: String!
}

input FeedbackEntryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [FeedbackEntryScalarWhereInput!]
  OR: [FeedbackEntryScalarWhereInput!]
  NOT: [FeedbackEntryScalarWhereInput!]
}

type FeedbackEntrySubscriptionPayload {
  mutation: MutationType!
  node: FeedbackEntry
  updatedFields: [String!]
  previousValues: FeedbackEntryPreviousValues
}

input FeedbackEntrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeedbackEntryWhereInput
  AND: [FeedbackEntrySubscriptionWhereInput!]
  OR: [FeedbackEntrySubscriptionWhereInput!]
  NOT: [FeedbackEntrySubscriptionWhereInput!]
}

input FeedbackEntryUpdateInput {
  CoachFeedback: CoachFeedbackUpdateOneRequiredWithoutFeedbackInput
  title: String
  content: String
}

input FeedbackEntryUpdateManyDataInput {
  title: String
  content: String
}

input FeedbackEntryUpdateManyMutationInput {
  title: String
  content: String
}

input FeedbackEntryUpdateManyWithoutCoachFeedbackInput {
  create: [FeedbackEntryCreateWithoutCoachFeedbackInput!]
  delete: [FeedbackEntryWhereUniqueInput!]
  connect: [FeedbackEntryWhereUniqueInput!]
  set: [FeedbackEntryWhereUniqueInput!]
  disconnect: [FeedbackEntryWhereUniqueInput!]
  update: [FeedbackEntryUpdateWithWhereUniqueWithoutCoachFeedbackInput!]
  upsert: [FeedbackEntryUpsertWithWhereUniqueWithoutCoachFeedbackInput!]
  deleteMany: [FeedbackEntryScalarWhereInput!]
  updateMany: [FeedbackEntryUpdateManyWithWhereNestedInput!]
}

input FeedbackEntryUpdateManyWithWhereNestedInput {
  where: FeedbackEntryScalarWhereInput!
  data: FeedbackEntryUpdateManyDataInput!
}

input FeedbackEntryUpdateWithoutCoachFeedbackDataInput {
  title: String
  content: String
}

input FeedbackEntryUpdateWithWhereUniqueWithoutCoachFeedbackInput {
  where: FeedbackEntryWhereUniqueInput!
  data: FeedbackEntryUpdateWithoutCoachFeedbackDataInput!
}

input FeedbackEntryUpsertWithWhereUniqueWithoutCoachFeedbackInput {
  where: FeedbackEntryWhereUniqueInput!
  update: FeedbackEntryUpdateWithoutCoachFeedbackDataInput!
  create: FeedbackEntryCreateWithoutCoachFeedbackInput!
}

input FeedbackEntryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  CoachFeedback: CoachFeedbackWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [FeedbackEntryWhereInput!]
  OR: [FeedbackEntryWhereInput!]
  NOT: [FeedbackEntryWhereInput!]
}

input FeedbackEntryWhereUniqueInput {
  id: ID
}

type IQJobInfo {
  id: ID!
  year: Int!
  month: Int!
  day: Int!
  hour: Int!
  minute: Int!
  job: Job!
  availability(where: ListingAvailabilityWhereInput, orderBy: ListingAvailabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ListingAvailability!]
  pending: Boolean
  confirmed: Boolean
  interviewGoals: String
  interviewQuestions: String
  resumeURL: String
}

type IQJobInfoConnection {
  pageInfo: PageInfo!
  edges: [IQJobInfoEdge]!
  aggregate: AggregateIQJobInfo!
}

input IQJobInfoCreateInput {
  id: ID
  year: Int!
  month: Int!
  day: Int!
  hour: Int!
  minute: Int!
  job: JobCreateOneInput!
  availability: ListingAvailabilityCreateManyInput
  pending: Boolean
  confirmed: Boolean
  interviewGoals: String
  interviewQuestions: String
  resumeURL: String
}

type IQJobInfoEdge {
  node: IQJobInfo!
  cursor: String!
}

enum IQJobInfoOrderByInput {
  id_ASC
  id_DESC
  year_ASC
  year_DESC
  month_ASC
  month_DESC
  day_ASC
  day_DESC
  hour_ASC
  hour_DESC
  minute_ASC
  minute_DESC
  pending_ASC
  pending_DESC
  confirmed_ASC
  confirmed_DESC
  interviewGoals_ASC
  interviewGoals_DESC
  interviewQuestions_ASC
  interviewQuestions_DESC
  resumeURL_ASC
  resumeURL_DESC
}

type IQJobInfoPreviousValues {
  id: ID!
  year: Int!
  month: Int!
  day: Int!
  hour: Int!
  minute: Int!
  pending: Boolean
  confirmed: Boolean
  interviewGoals: String
  interviewQuestions: String
  resumeURL: String
}

type IQJobInfoSubscriptionPayload {
  mutation: MutationType!
  node: IQJobInfo
  updatedFields: [String!]
  previousValues: IQJobInfoPreviousValues
}

input IQJobInfoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IQJobInfoWhereInput
  AND: [IQJobInfoSubscriptionWhereInput!]
  OR: [IQJobInfoSubscriptionWhereInput!]
  NOT: [IQJobInfoSubscriptionWhereInput!]
}

input IQJobInfoUpdateInput {
  year: Int
  month: Int
  day: Int
  hour: Int
  minute: Int
  job: JobUpdateOneRequiredInput
  availability: ListingAvailabilityUpdateManyInput
  pending: Boolean
  confirmed: Boolean
  interviewGoals: String
  interviewQuestions: String
  resumeURL: String
}

input IQJobInfoUpdateManyMutationInput {
  year: Int
  month: Int
  day: Int
  hour: Int
  minute: Int
  pending: Boolean
  confirmed: Boolean
  interviewGoals: String
  interviewQuestions: String
  resumeURL: String
}

input IQJobInfoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  month: Int
  month_not: Int
  month_in: [Int!]
  month_not_in: [Int!]
  month_lt: Int
  month_lte: Int
  month_gt: Int
  month_gte: Int
  day: Int
  day_not: Int
  day_in: [Int!]
  day_not_in: [Int!]
  day_lt: Int
  day_lte: Int
  day_gt: Int
  day_gte: Int
  hour: Int
  hour_not: Int
  hour_in: [Int!]
  hour_not_in: [Int!]
  hour_lt: Int
  hour_lte: Int
  hour_gt: Int
  hour_gte: Int
  minute: Int
  minute_not: Int
  minute_in: [Int!]
  minute_not_in: [Int!]
  minute_lt: Int
  minute_lte: Int
  minute_gt: Int
  minute_gte: Int
  job: JobWhereInput
  availability_every: ListingAvailabilityWhereInput
  availability_some: ListingAvailabilityWhereInput
  availability_none: ListingAvailabilityWhereInput
  pending: Boolean
  pending_not: Boolean
  confirmed: Boolean
  confirmed_not: Boolean
  interviewGoals: String
  interviewGoals_not: String
  interviewGoals_in: [String!]
  interviewGoals_not_in: [String!]
  interviewGoals_lt: String
  interviewGoals_lte: String
  interviewGoals_gt: String
  interviewGoals_gte: String
  interviewGoals_contains: String
  interviewGoals_not_contains: String
  interviewGoals_starts_with: String
  interviewGoals_not_starts_with: String
  interviewGoals_ends_with: String
  interviewGoals_not_ends_with: String
  interviewQuestions: String
  interviewQuestions_not: String
  interviewQuestions_in: [String!]
  interviewQuestions_not_in: [String!]
  interviewQuestions_lt: String
  interviewQuestions_lte: String
  interviewQuestions_gt: String
  interviewQuestions_gte: String
  interviewQuestions_contains: String
  interviewQuestions_not_contains: String
  interviewQuestions_starts_with: String
  interviewQuestions_not_starts_with: String
  interviewQuestions_ends_with: String
  interviewQuestions_not_ends_with: String
  resumeURL: String
  resumeURL_not: String
  resumeURL_in: [String!]
  resumeURL_not_in: [String!]
  resumeURL_lt: String
  resumeURL_lte: String
  resumeURL_gt: String
  resumeURL_gte: String
  resumeURL_contains: String
  resumeURL_not_contains: String
  resumeURL_starts_with: String
  resumeURL_not_starts_with: String
  resumeURL_ends_with: String
  resumeURL_not_ends_with: String
  AND: [IQJobInfoWhereInput!]
  OR: [IQJobInfoWhereInput!]
  NOT: [IQJobInfoWhereInput!]
}

input IQJobInfoWhereUniqueInput {
  id: ID
}

type Job {
  id: ID!
  coach: User!
  seeker: User!
  listing: ServiceListing!
  microservice: Microservice!
  dateRequested: DateTime
  dateAccepted: DateTime
  dateCompleted: DateTime
  pending: Boolean
  accepted: Boolean
  completed: Boolean
}

type JobConnection {
  pageInfo: PageInfo!
  edges: [JobEdge]!
  aggregate: AggregateJob!
}

input JobCreateInput {
  id: ID
  coach: UserCreateOneInput!
  seeker: UserCreateOneInput!
  listing: ServiceListingCreateOneInput!
  microservice: Microservice!
  dateRequested: DateTime
  dateAccepted: DateTime
  dateCompleted: DateTime
  pending: Boolean
  accepted: Boolean
  completed: Boolean
}

input JobCreateOneInput {
  create: JobCreateInput
  connect: JobWhereUniqueInput
}

type JobEdge {
  node: Job!
  cursor: String!
}

enum JobOrderByInput {
  id_ASC
  id_DESC
  microservice_ASC
  microservice_DESC
  dateRequested_ASC
  dateRequested_DESC
  dateAccepted_ASC
  dateAccepted_DESC
  dateCompleted_ASC
  dateCompleted_DESC
  pending_ASC
  pending_DESC
  accepted_ASC
  accepted_DESC
  completed_ASC
  completed_DESC
}

type JobPreviousValues {
  id: ID!
  microservice: Microservice!
  dateRequested: DateTime
  dateAccepted: DateTime
  dateCompleted: DateTime
  pending: Boolean
  accepted: Boolean
  completed: Boolean
}

type JobSubscriptionPayload {
  mutation: MutationType!
  node: Job
  updatedFields: [String!]
  previousValues: JobPreviousValues
}

input JobSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: JobWhereInput
  AND: [JobSubscriptionWhereInput!]
  OR: [JobSubscriptionWhereInput!]
  NOT: [JobSubscriptionWhereInput!]
}

input JobUpdateDataInput {
  coach: UserUpdateOneRequiredInput
  seeker: UserUpdateOneRequiredInput
  listing: ServiceListingUpdateOneRequiredInput
  microservice: Microservice
  dateRequested: DateTime
  dateAccepted: DateTime
  dateCompleted: DateTime
  pending: Boolean
  accepted: Boolean
  completed: Boolean
}

input JobUpdateInput {
  coach: UserUpdateOneRequiredInput
  seeker: UserUpdateOneRequiredInput
  listing: ServiceListingUpdateOneRequiredInput
  microservice: Microservice
  dateRequested: DateTime
  dateAccepted: DateTime
  dateCompleted: DateTime
  pending: Boolean
  accepted: Boolean
  completed: Boolean
}

input JobUpdateManyMutationInput {
  microservice: Microservice
  dateRequested: DateTime
  dateAccepted: DateTime
  dateCompleted: DateTime
  pending: Boolean
  accepted: Boolean
  completed: Boolean
}

input JobUpdateOneRequiredInput {
  create: JobCreateInput
  update: JobUpdateDataInput
  upsert: JobUpsertNestedInput
  connect: JobWhereUniqueInput
}

input JobUpsertNestedInput {
  update: JobUpdateDataInput!
  create: JobCreateInput!
}

input JobWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  coach: UserWhereInput
  seeker: UserWhereInput
  listing: ServiceListingWhereInput
  microservice: Microservice
  microservice_not: Microservice
  microservice_in: [Microservice!]
  microservice_not_in: [Microservice!]
  dateRequested: DateTime
  dateRequested_not: DateTime
  dateRequested_in: [DateTime!]
  dateRequested_not_in: [DateTime!]
  dateRequested_lt: DateTime
  dateRequested_lte: DateTime
  dateRequested_gt: DateTime
  dateRequested_gte: DateTime
  dateAccepted: DateTime
  dateAccepted_not: DateTime
  dateAccepted_in: [DateTime!]
  dateAccepted_not_in: [DateTime!]
  dateAccepted_lt: DateTime
  dateAccepted_lte: DateTime
  dateAccepted_gt: DateTime
  dateAccepted_gte: DateTime
  dateCompleted: DateTime
  dateCompleted_not: DateTime
  dateCompleted_in: [DateTime!]
  dateCompleted_not_in: [DateTime!]
  dateCompleted_lt: DateTime
  dateCompleted_lte: DateTime
  dateCompleted_gt: DateTime
  dateCompleted_gte: DateTime
  pending: Boolean
  pending_not: Boolean
  accepted: Boolean
  accepted_not: Boolean
  completed: Boolean
  completed_not: Boolean
  AND: [JobWhereInput!]
  OR: [JobWhereInput!]
  NOT: [JobWhereInput!]
}

input JobWhereUniqueInput {
  id: ID
}

type ListingAvailability {
  id: ID!
  hour: Int!
  minute: Int!
  coach: User!
  listing: ServiceListing!
  year: Int!
  month: Int!
  day: Int!
  isOpen: Boolean!
  recurring: Boolean!
}

type ListingAvailabilityConnection {
  pageInfo: PageInfo!
  edges: [ListingAvailabilityEdge]!
  aggregate: AggregateListingAvailability!
}

input ListingAvailabilityCreateInput {
  id: ID
  hour: Int!
  minute: Int!
  coach: UserCreateOneInput!
  listing: ServiceListingCreateOneInput!
  year: Int!
  month: Int!
  day: Int!
  isOpen: Boolean!
  recurring: Boolean!
}

input ListingAvailabilityCreateManyInput {
  create: [ListingAvailabilityCreateInput!]
  connect: [ListingAvailabilityWhereUniqueInput!]
}

type ListingAvailabilityEdge {
  node: ListingAvailability!
  cursor: String!
}

enum ListingAvailabilityOrderByInput {
  id_ASC
  id_DESC
  hour_ASC
  hour_DESC
  minute_ASC
  minute_DESC
  year_ASC
  year_DESC
  month_ASC
  month_DESC
  day_ASC
  day_DESC
  isOpen_ASC
  isOpen_DESC
  recurring_ASC
  recurring_DESC
}

type ListingAvailabilityPreviousValues {
  id: ID!
  hour: Int!
  minute: Int!
  year: Int!
  month: Int!
  day: Int!
  isOpen: Boolean!
  recurring: Boolean!
}

input ListingAvailabilityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  hour: Int
  hour_not: Int
  hour_in: [Int!]
  hour_not_in: [Int!]
  hour_lt: Int
  hour_lte: Int
  hour_gt: Int
  hour_gte: Int
  minute: Int
  minute_not: Int
  minute_in: [Int!]
  minute_not_in: [Int!]
  minute_lt: Int
  minute_lte: Int
  minute_gt: Int
  minute_gte: Int
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  month: Int
  month_not: Int
  month_in: [Int!]
  month_not_in: [Int!]
  month_lt: Int
  month_lte: Int
  month_gt: Int
  month_gte: Int
  day: Int
  day_not: Int
  day_in: [Int!]
  day_not_in: [Int!]
  day_lt: Int
  day_lte: Int
  day_gt: Int
  day_gte: Int
  isOpen: Boolean
  isOpen_not: Boolean
  recurring: Boolean
  recurring_not: Boolean
  AND: [ListingAvailabilityScalarWhereInput!]
  OR: [ListingAvailabilityScalarWhereInput!]
  NOT: [ListingAvailabilityScalarWhereInput!]
}

type ListingAvailabilitySubscriptionPayload {
  mutation: MutationType!
  node: ListingAvailability
  updatedFields: [String!]
  previousValues: ListingAvailabilityPreviousValues
}

input ListingAvailabilitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ListingAvailabilityWhereInput
  AND: [ListingAvailabilitySubscriptionWhereInput!]
  OR: [ListingAvailabilitySubscriptionWhereInput!]
  NOT: [ListingAvailabilitySubscriptionWhereInput!]
}

input ListingAvailabilityUpdateDataInput {
  hour: Int
  minute: Int
  coach: UserUpdateOneRequiredInput
  listing: ServiceListingUpdateOneRequiredInput
  year: Int
  month: Int
  day: Int
  isOpen: Boolean
  recurring: Boolean
}

input ListingAvailabilityUpdateInput {
  hour: Int
  minute: Int
  coach: UserUpdateOneRequiredInput
  listing: ServiceListingUpdateOneRequiredInput
  year: Int
  month: Int
  day: Int
  isOpen: Boolean
  recurring: Boolean
}

input ListingAvailabilityUpdateManyDataInput {
  hour: Int
  minute: Int
  year: Int
  month: Int
  day: Int
  isOpen: Boolean
  recurring: Boolean
}

input ListingAvailabilityUpdateManyInput {
  create: [ListingAvailabilityCreateInput!]
  update: [ListingAvailabilityUpdateWithWhereUniqueNestedInput!]
  upsert: [ListingAvailabilityUpsertWithWhereUniqueNestedInput!]
  delete: [ListingAvailabilityWhereUniqueInput!]
  connect: [ListingAvailabilityWhereUniqueInput!]
  set: [ListingAvailabilityWhereUniqueInput!]
  disconnect: [ListingAvailabilityWhereUniqueInput!]
  deleteMany: [ListingAvailabilityScalarWhereInput!]
  updateMany: [ListingAvailabilityUpdateManyWithWhereNestedInput!]
}

input ListingAvailabilityUpdateManyMutationInput {
  hour: Int
  minute: Int
  year: Int
  month: Int
  day: Int
  isOpen: Boolean
  recurring: Boolean
}

input ListingAvailabilityUpdateManyWithWhereNestedInput {
  where: ListingAvailabilityScalarWhereInput!
  data: ListingAvailabilityUpdateManyDataInput!
}

input ListingAvailabilityUpdateWithWhereUniqueNestedInput {
  where: ListingAvailabilityWhereUniqueInput!
  data: ListingAvailabilityUpdateDataInput!
}

input ListingAvailabilityUpsertWithWhereUniqueNestedInput {
  where: ListingAvailabilityWhereUniqueInput!
  update: ListingAvailabilityUpdateDataInput!
  create: ListingAvailabilityCreateInput!
}

input ListingAvailabilityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  hour: Int
  hour_not: Int
  hour_in: [Int!]
  hour_not_in: [Int!]
  hour_lt: Int
  hour_lte: Int
  hour_gt: Int
  hour_gte: Int
  minute: Int
  minute_not: Int
  minute_in: [Int!]
  minute_not_in: [Int!]
  minute_lt: Int
  minute_lte: Int
  minute_gt: Int
  minute_gte: Int
  coach: UserWhereInput
  listing: ServiceListingWhereInput
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  month: Int
  month_not: Int
  month_in: [Int!]
  month_not_in: [Int!]
  month_lt: Int
  month_lte: Int
  month_gt: Int
  month_gte: Int
  day: Int
  day_not: Int
  day_in: [Int!]
  day_not_in: [Int!]
  day_lt: Int
  day_lte: Int
  day_gt: Int
  day_gte: Int
  isOpen: Boolean
  isOpen_not: Boolean
  recurring: Boolean
  recurring_not: Boolean
  AND: [ListingAvailabilityWhereInput!]
  OR: [ListingAvailabilityWhereInput!]
  NOT: [ListingAvailabilityWhereInput!]
}

input ListingAvailabilityWhereUniqueInput {
  id: ID
}

type ListingIndustry {
  id: ID!
  name: String!
}

type ListingIndustryConnection {
  pageInfo: PageInfo!
  edges: [ListingIndustryEdge]!
  aggregate: AggregateListingIndustry!
}

input ListingIndustryCreateInput {
  id: ID
  name: String!
}

input ListingIndustryCreateManyInput {
  create: [ListingIndustryCreateInput!]
  connect: [ListingIndustryWhereUniqueInput!]
}

type ListingIndustryEdge {
  node: ListingIndustry!
  cursor: String!
}

enum ListingIndustryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ListingIndustryPreviousValues {
  id: ID!
  name: String!
}

input ListingIndustryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ListingIndustryScalarWhereInput!]
  OR: [ListingIndustryScalarWhereInput!]
  NOT: [ListingIndustryScalarWhereInput!]
}

type ListingIndustrySubscriptionPayload {
  mutation: MutationType!
  node: ListingIndustry
  updatedFields: [String!]
  previousValues: ListingIndustryPreviousValues
}

input ListingIndustrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ListingIndustryWhereInput
  AND: [ListingIndustrySubscriptionWhereInput!]
  OR: [ListingIndustrySubscriptionWhereInput!]
  NOT: [ListingIndustrySubscriptionWhereInput!]
}

input ListingIndustryUpdateDataInput {
  name: String
}

input ListingIndustryUpdateInput {
  name: String
}

input ListingIndustryUpdateManyDataInput {
  name: String
}

input ListingIndustryUpdateManyInput {
  create: [ListingIndustryCreateInput!]
  update: [ListingIndustryUpdateWithWhereUniqueNestedInput!]
  upsert: [ListingIndustryUpsertWithWhereUniqueNestedInput!]
  delete: [ListingIndustryWhereUniqueInput!]
  connect: [ListingIndustryWhereUniqueInput!]
  set: [ListingIndustryWhereUniqueInput!]
  disconnect: [ListingIndustryWhereUniqueInput!]
  deleteMany: [ListingIndustryScalarWhereInput!]
  updateMany: [ListingIndustryUpdateManyWithWhereNestedInput!]
}

input ListingIndustryUpdateManyMutationInput {
  name: String
}

input ListingIndustryUpdateManyWithWhereNestedInput {
  where: ListingIndustryScalarWhereInput!
  data: ListingIndustryUpdateManyDataInput!
}

input ListingIndustryUpdateWithWhereUniqueNestedInput {
  where: ListingIndustryWhereUniqueInput!
  data: ListingIndustryUpdateDataInput!
}

input ListingIndustryUpsertWithWhereUniqueNestedInput {
  where: ListingIndustryWhereUniqueInput!
  update: ListingIndustryUpdateDataInput!
  create: ListingIndustryCreateInput!
}

input ListingIndustryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ListingIndustryWhereInput!]
  OR: [ListingIndustryWhereInput!]
  NOT: [ListingIndustryWhereInput!]
}

input ListingIndustryWhereUniqueInput {
  id: ID
}

type ListingTag {
  id: ID!
  name: String!
}

type ListingTagConnection {
  pageInfo: PageInfo!
  edges: [ListingTagEdge]!
  aggregate: AggregateListingTag!
}

input ListingTagCreateInput {
  id: ID
  name: String!
}

input ListingTagCreateManyInput {
  create: [ListingTagCreateInput!]
  connect: [ListingTagWhereUniqueInput!]
}

type ListingTagEdge {
  node: ListingTag!
  cursor: String!
}

enum ListingTagOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ListingTagPreviousValues {
  id: ID!
  name: String!
}

input ListingTagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ListingTagScalarWhereInput!]
  OR: [ListingTagScalarWhereInput!]
  NOT: [ListingTagScalarWhereInput!]
}

type ListingTagSubscriptionPayload {
  mutation: MutationType!
  node: ListingTag
  updatedFields: [String!]
  previousValues: ListingTagPreviousValues
}

input ListingTagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ListingTagWhereInput
  AND: [ListingTagSubscriptionWhereInput!]
  OR: [ListingTagSubscriptionWhereInput!]
  NOT: [ListingTagSubscriptionWhereInput!]
}

input ListingTagUpdateDataInput {
  name: String
}

input ListingTagUpdateInput {
  name: String
}

input ListingTagUpdateManyDataInput {
  name: String
}

input ListingTagUpdateManyInput {
  create: [ListingTagCreateInput!]
  update: [ListingTagUpdateWithWhereUniqueNestedInput!]
  upsert: [ListingTagUpsertWithWhereUniqueNestedInput!]
  delete: [ListingTagWhereUniqueInput!]
  connect: [ListingTagWhereUniqueInput!]
  set: [ListingTagWhereUniqueInput!]
  disconnect: [ListingTagWhereUniqueInput!]
  deleteMany: [ListingTagScalarWhereInput!]
  updateMany: [ListingTagUpdateManyWithWhereNestedInput!]
}

input ListingTagUpdateManyMutationInput {
  name: String
}

input ListingTagUpdateManyWithWhereNestedInput {
  where: ListingTagScalarWhereInput!
  data: ListingTagUpdateManyDataInput!
}

input ListingTagUpdateWithWhereUniqueNestedInput {
  where: ListingTagWhereUniqueInput!
  data: ListingTagUpdateDataInput!
}

input ListingTagUpsertWithWhereUniqueNestedInput {
  where: ListingTagWhereUniqueInput!
  update: ListingTagUpdateDataInput!
  create: ListingTagCreateInput!
}

input ListingTagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ListingTagWhereInput!]
  OR: [ListingTagWhereInput!]
  NOT: [ListingTagWhereInput!]
}

input ListingTagWhereUniqueInput {
  id: ID
}

scalar Long

enum Microservice {
  INTERVIEWQ
  RESUMEQ
}

type Mutation {
  createCoachFeedback(data: CoachFeedbackCreateInput!): CoachFeedback!
  updateCoachFeedback(data: CoachFeedbackUpdateInput!, where: CoachFeedbackWhereUniqueInput!): CoachFeedback
  updateManyCoachFeedbacks(data: CoachFeedbackUpdateManyMutationInput!, where: CoachFeedbackWhereInput): BatchPayload!
  upsertCoachFeedback(where: CoachFeedbackWhereUniqueInput!, create: CoachFeedbackCreateInput!, update: CoachFeedbackUpdateInput!): CoachFeedback!
  deleteCoachFeedback(where: CoachFeedbackWhereUniqueInput!): CoachFeedback
  deleteManyCoachFeedbacks(where: CoachFeedbackWhereInput): BatchPayload!
  createFeedbackEntry(data: FeedbackEntryCreateInput!): FeedbackEntry!
  updateFeedbackEntry(data: FeedbackEntryUpdateInput!, where: FeedbackEntryWhereUniqueInput!): FeedbackEntry
  updateManyFeedbackEntries(data: FeedbackEntryUpdateManyMutationInput!, where: FeedbackEntryWhereInput): BatchPayload!
  upsertFeedbackEntry(where: FeedbackEntryWhereUniqueInput!, create: FeedbackEntryCreateInput!, update: FeedbackEntryUpdateInput!): FeedbackEntry!
  deleteFeedbackEntry(where: FeedbackEntryWhereUniqueInput!): FeedbackEntry
  deleteManyFeedbackEntries(where: FeedbackEntryWhereInput): BatchPayload!
  createIQJobInfo(data: IQJobInfoCreateInput!): IQJobInfo!
  updateIQJobInfo(data: IQJobInfoUpdateInput!, where: IQJobInfoWhereUniqueInput!): IQJobInfo
  updateManyIQJobInfoes(data: IQJobInfoUpdateManyMutationInput!, where: IQJobInfoWhereInput): BatchPayload!
  upsertIQJobInfo(where: IQJobInfoWhereUniqueInput!, create: IQJobInfoCreateInput!, update: IQJobInfoUpdateInput!): IQJobInfo!
  deleteIQJobInfo(where: IQJobInfoWhereUniqueInput!): IQJobInfo
  deleteManyIQJobInfoes(where: IQJobInfoWhereInput): BatchPayload!
  createJob(data: JobCreateInput!): Job!
  updateJob(data: JobUpdateInput!, where: JobWhereUniqueInput!): Job
  updateManyJobs(data: JobUpdateManyMutationInput!, where: JobWhereInput): BatchPayload!
  upsertJob(where: JobWhereUniqueInput!, create: JobCreateInput!, update: JobUpdateInput!): Job!
  deleteJob(where: JobWhereUniqueInput!): Job
  deleteManyJobs(where: JobWhereInput): BatchPayload!
  createListingAvailability(data: ListingAvailabilityCreateInput!): ListingAvailability!
  updateListingAvailability(data: ListingAvailabilityUpdateInput!, where: ListingAvailabilityWhereUniqueInput!): ListingAvailability
  updateManyListingAvailabilities(data: ListingAvailabilityUpdateManyMutationInput!, where: ListingAvailabilityWhereInput): BatchPayload!
  upsertListingAvailability(where: ListingAvailabilityWhereUniqueInput!, create: ListingAvailabilityCreateInput!, update: ListingAvailabilityUpdateInput!): ListingAvailability!
  deleteListingAvailability(where: ListingAvailabilityWhereUniqueInput!): ListingAvailability
  deleteManyListingAvailabilities(where: ListingAvailabilityWhereInput): BatchPayload!
  createListingIndustry(data: ListingIndustryCreateInput!): ListingIndustry!
  updateListingIndustry(data: ListingIndustryUpdateInput!, where: ListingIndustryWhereUniqueInput!): ListingIndustry
  updateManyListingIndustries(data: ListingIndustryUpdateManyMutationInput!, where: ListingIndustryWhereInput): BatchPayload!
  upsertListingIndustry(where: ListingIndustryWhereUniqueInput!, create: ListingIndustryCreateInput!, update: ListingIndustryUpdateInput!): ListingIndustry!
  deleteListingIndustry(where: ListingIndustryWhereUniqueInput!): ListingIndustry
  deleteManyListingIndustries(where: ListingIndustryWhereInput): BatchPayload!
  createListingTag(data: ListingTagCreateInput!): ListingTag!
  updateListingTag(data: ListingTagUpdateInput!, where: ListingTagWhereUniqueInput!): ListingTag
  updateManyListingTags(data: ListingTagUpdateManyMutationInput!, where: ListingTagWhereInput): BatchPayload!
  upsertListingTag(where: ListingTagWhereUniqueInput!, create: ListingTagCreateInput!, update: ListingTagUpdateInput!): ListingTag!
  deleteListingTag(where: ListingTagWhereUniqueInput!): ListingTag
  deleteManyListingTags(where: ListingTagWhereInput): BatchPayload!
  createSeekerReview(data: SeekerReviewCreateInput!): SeekerReview!
  updateSeekerReview(data: SeekerReviewUpdateInput!, where: SeekerReviewWhereUniqueInput!): SeekerReview
  updateManySeekerReviews(data: SeekerReviewUpdateManyMutationInput!, where: SeekerReviewWhereInput): BatchPayload!
  upsertSeekerReview(where: SeekerReviewWhereUniqueInput!, create: SeekerReviewCreateInput!, update: SeekerReviewUpdateInput!): SeekerReview!
  deleteSeekerReview(where: SeekerReviewWhereUniqueInput!): SeekerReview
  deleteManySeekerReviews(where: SeekerReviewWhereInput): BatchPayload!
  createSeekerReviewResponse(data: SeekerReviewResponseCreateInput!): SeekerReviewResponse!
  updateSeekerReviewResponse(data: SeekerReviewResponseUpdateInput!, where: SeekerReviewResponseWhereUniqueInput!): SeekerReviewResponse
  updateManySeekerReviewResponses(data: SeekerReviewResponseUpdateManyMutationInput!, where: SeekerReviewResponseWhereInput): BatchPayload!
  upsertSeekerReviewResponse(where: SeekerReviewResponseWhereUniqueInput!, create: SeekerReviewResponseCreateInput!, update: SeekerReviewResponseUpdateInput!): SeekerReviewResponse!
  deleteSeekerReviewResponse(where: SeekerReviewResponseWhereUniqueInput!): SeekerReviewResponse
  deleteManySeekerReviewResponses(where: SeekerReviewResponseWhereInput): BatchPayload!
  createServiceListing(data: ServiceListingCreateInput!): ServiceListing!
  updateServiceListing(data: ServiceListingUpdateInput!, where: ServiceListingWhereUniqueInput!): ServiceListing
  updateManyServiceListings(data: ServiceListingUpdateManyMutationInput!, where: ServiceListingWhereInput): BatchPayload!
  upsertServiceListing(where: ServiceListingWhereUniqueInput!, create: ServiceListingCreateInput!, update: ServiceListingUpdateInput!): ServiceListing!
  deleteServiceListing(where: ServiceListingWhereUniqueInput!): ServiceListing
  deleteManyServiceListings(where: ServiceListingWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  coachFeedback(where: CoachFeedbackWhereUniqueInput!): CoachFeedback
  coachFeedbacks(where: CoachFeedbackWhereInput, orderBy: CoachFeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CoachFeedback]!
  coachFeedbacksConnection(where: CoachFeedbackWhereInput, orderBy: CoachFeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CoachFeedbackConnection!
  feedbackEntry(where: FeedbackEntryWhereUniqueInput!): FeedbackEntry
  feedbackEntries(where: FeedbackEntryWhereInput, orderBy: FeedbackEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FeedbackEntry]!
  feedbackEntriesConnection(where: FeedbackEntryWhereInput, orderBy: FeedbackEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeedbackEntryConnection!
  iQJobInfo(where: IQJobInfoWhereUniqueInput!): IQJobInfo
  iQJobInfoes(where: IQJobInfoWhereInput, orderBy: IQJobInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IQJobInfo]!
  iQJobInfoesConnection(where: IQJobInfoWhereInput, orderBy: IQJobInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IQJobInfoConnection!
  job(where: JobWhereUniqueInput!): Job
  jobs(where: JobWhereInput, orderBy: JobOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Job]!
  jobsConnection(where: JobWhereInput, orderBy: JobOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): JobConnection!
  listingAvailability(where: ListingAvailabilityWhereUniqueInput!): ListingAvailability
  listingAvailabilities(where: ListingAvailabilityWhereInput, orderBy: ListingAvailabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ListingAvailability]!
  listingAvailabilitiesConnection(where: ListingAvailabilityWhereInput, orderBy: ListingAvailabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ListingAvailabilityConnection!
  listingIndustry(where: ListingIndustryWhereUniqueInput!): ListingIndustry
  listingIndustries(where: ListingIndustryWhereInput, orderBy: ListingIndustryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ListingIndustry]!
  listingIndustriesConnection(where: ListingIndustryWhereInput, orderBy: ListingIndustryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ListingIndustryConnection!
  listingTag(where: ListingTagWhereUniqueInput!): ListingTag
  listingTags(where: ListingTagWhereInput, orderBy: ListingTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ListingTag]!
  listingTagsConnection(where: ListingTagWhereInput, orderBy: ListingTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ListingTagConnection!
  seekerReview(where: SeekerReviewWhereUniqueInput!): SeekerReview
  seekerReviews(where: SeekerReviewWhereInput, orderBy: SeekerReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SeekerReview]!
  seekerReviewsConnection(where: SeekerReviewWhereInput, orderBy: SeekerReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeekerReviewConnection!
  seekerReviewResponse(where: SeekerReviewResponseWhereUniqueInput!): SeekerReviewResponse
  seekerReviewResponses(where: SeekerReviewResponseWhereInput, orderBy: SeekerReviewResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SeekerReviewResponse]!
  seekerReviewResponsesConnection(where: SeekerReviewResponseWhereInput, orderBy: SeekerReviewResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeekerReviewResponseConnection!
  serviceListing(where: ServiceListingWhereUniqueInput!): ServiceListing
  serviceListings(where: ServiceListingWhereInput, orderBy: ServiceListingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ServiceListing]!
  serviceListingsConnection(where: ServiceListingWhereInput, orderBy: ServiceListingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ServiceListingConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type SeekerReview {
  id: ID!
  coach: User!
  seeker: User!
  job: String!
  rating: Int!
  review: String
  createdAt: DateTime!
  updatedAt: DateTime!
  response: SeekerReviewResponse
  microservice: Microservice!
}

type SeekerReviewConnection {
  pageInfo: PageInfo!
  edges: [SeekerReviewEdge]!
  aggregate: AggregateSeekerReview!
}

input SeekerReviewCreateInput {
  id: ID
  coach: UserCreateOneInput!
  seeker: UserCreateOneInput!
  job: String!
  rating: Int!
  review: String
  response: SeekerReviewResponseCreateOneWithoutReviewInput
  microservice: Microservice!
}

input SeekerReviewCreateOneWithoutResponseInput {
  create: SeekerReviewCreateWithoutResponseInput
  connect: SeekerReviewWhereUniqueInput
}

input SeekerReviewCreateWithoutResponseInput {
  id: ID
  coach: UserCreateOneInput!
  seeker: UserCreateOneInput!
  job: String!
  rating: Int!
  review: String
  microservice: Microservice!
}

type SeekerReviewEdge {
  node: SeekerReview!
  cursor: String!
}

enum SeekerReviewOrderByInput {
  id_ASC
  id_DESC
  job_ASC
  job_DESC
  rating_ASC
  rating_DESC
  review_ASC
  review_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  microservice_ASC
  microservice_DESC
}

type SeekerReviewPreviousValues {
  id: ID!
  job: String!
  rating: Int!
  review: String
  createdAt: DateTime!
  updatedAt: DateTime!
  microservice: Microservice!
}

type SeekerReviewResponse {
  id: ID!
  review: SeekerReview!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeekerReviewResponseConnection {
  pageInfo: PageInfo!
  edges: [SeekerReviewResponseEdge]!
  aggregate: AggregateSeekerReviewResponse!
}

input SeekerReviewResponseCreateInput {
  id: ID
  review: SeekerReviewCreateOneWithoutResponseInput!
  text: String!
}

input SeekerReviewResponseCreateOneWithoutReviewInput {
  create: SeekerReviewResponseCreateWithoutReviewInput
  connect: SeekerReviewResponseWhereUniqueInput
}

input SeekerReviewResponseCreateWithoutReviewInput {
  id: ID
  text: String!
}

type SeekerReviewResponseEdge {
  node: SeekerReviewResponse!
  cursor: String!
}

enum SeekerReviewResponseOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SeekerReviewResponsePreviousValues {
  id: ID!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeekerReviewResponseSubscriptionPayload {
  mutation: MutationType!
  node: SeekerReviewResponse
  updatedFields: [String!]
  previousValues: SeekerReviewResponsePreviousValues
}

input SeekerReviewResponseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeekerReviewResponseWhereInput
  AND: [SeekerReviewResponseSubscriptionWhereInput!]
  OR: [SeekerReviewResponseSubscriptionWhereInput!]
  NOT: [SeekerReviewResponseSubscriptionWhereInput!]
}

input SeekerReviewResponseUpdateInput {
  review: SeekerReviewUpdateOneRequiredWithoutResponseInput
  text: String
}

input SeekerReviewResponseUpdateManyMutationInput {
  text: String
}

input SeekerReviewResponseUpdateOneWithoutReviewInput {
  create: SeekerReviewResponseCreateWithoutReviewInput
  update: SeekerReviewResponseUpdateWithoutReviewDataInput
  upsert: SeekerReviewResponseUpsertWithoutReviewInput
  delete: Boolean
  disconnect: Boolean
  connect: SeekerReviewResponseWhereUniqueInput
}

input SeekerReviewResponseUpdateWithoutReviewDataInput {
  text: String
}

input SeekerReviewResponseUpsertWithoutReviewInput {
  update: SeekerReviewResponseUpdateWithoutReviewDataInput!
  create: SeekerReviewResponseCreateWithoutReviewInput!
}

input SeekerReviewResponseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  review: SeekerReviewWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SeekerReviewResponseWhereInput!]
  OR: [SeekerReviewResponseWhereInput!]
  NOT: [SeekerReviewResponseWhereInput!]
}

input SeekerReviewResponseWhereUniqueInput {
  id: ID
}

type SeekerReviewSubscriptionPayload {
  mutation: MutationType!
  node: SeekerReview
  updatedFields: [String!]
  previousValues: SeekerReviewPreviousValues
}

input SeekerReviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeekerReviewWhereInput
  AND: [SeekerReviewSubscriptionWhereInput!]
  OR: [SeekerReviewSubscriptionWhereInput!]
  NOT: [SeekerReviewSubscriptionWhereInput!]
}

input SeekerReviewUpdateInput {
  coach: UserUpdateOneRequiredInput
  seeker: UserUpdateOneRequiredInput
  job: String
  rating: Int
  review: String
  response: SeekerReviewResponseUpdateOneWithoutReviewInput
  microservice: Microservice
}

input SeekerReviewUpdateManyMutationInput {
  job: String
  rating: Int
  review: String
  microservice: Microservice
}

input SeekerReviewUpdateOneRequiredWithoutResponseInput {
  create: SeekerReviewCreateWithoutResponseInput
  update: SeekerReviewUpdateWithoutResponseDataInput
  upsert: SeekerReviewUpsertWithoutResponseInput
  connect: SeekerReviewWhereUniqueInput
}

input SeekerReviewUpdateWithoutResponseDataInput {
  coach: UserUpdateOneRequiredInput
  seeker: UserUpdateOneRequiredInput
  job: String
  rating: Int
  review: String
  microservice: Microservice
}

input SeekerReviewUpsertWithoutResponseInput {
  update: SeekerReviewUpdateWithoutResponseDataInput!
  create: SeekerReviewCreateWithoutResponseInput!
}

input SeekerReviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  coach: UserWhereInput
  seeker: UserWhereInput
  job: String
  job_not: String
  job_in: [String!]
  job_not_in: [String!]
  job_lt: String
  job_lte: String
  job_gt: String
  job_gte: String
  job_contains: String
  job_not_contains: String
  job_starts_with: String
  job_not_starts_with: String
  job_ends_with: String
  job_not_ends_with: String
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  review: String
  review_not: String
  review_in: [String!]
  review_not_in: [String!]
  review_lt: String
  review_lte: String
  review_gt: String
  review_gte: String
  review_contains: String
  review_not_contains: String
  review_starts_with: String
  review_not_starts_with: String
  review_ends_with: String
  review_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  response: SeekerReviewResponseWhereInput
  microservice: Microservice
  microservice_not: Microservice
  microservice_in: [Microservice!]
  microservice_not_in: [Microservice!]
  AND: [SeekerReviewWhereInput!]
  OR: [SeekerReviewWhereInput!]
  NOT: [SeekerReviewWhereInput!]
}

input SeekerReviewWhereUniqueInput {
  id: ID
  job: String
}

type ServiceListing {
  id: ID!
  coach: User!
  description: String!
  price: Int!
  microservice: Microservice!
  tags(where: ListingTagWhereInput, orderBy: ListingTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ListingTag!]
  industry(where: ListingIndustryWhereInput, orderBy: ListingIndustryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ListingIndustry!]
}

type ServiceListingConnection {
  pageInfo: PageInfo!
  edges: [ServiceListingEdge]!
  aggregate: AggregateServiceListing!
}

input ServiceListingCreateInput {
  id: ID
  coach: UserCreateOneInput!
  description: String!
  price: Int!
  microservice: Microservice!
  tags: ListingTagCreateManyInput
  industry: ListingIndustryCreateManyInput
}

input ServiceListingCreateOneInput {
  create: ServiceListingCreateInput
  connect: ServiceListingWhereUniqueInput
}

type ServiceListingEdge {
  node: ServiceListing!
  cursor: String!
}

enum ServiceListingOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  price_ASC
  price_DESC
  microservice_ASC
  microservice_DESC
}

type ServiceListingPreviousValues {
  id: ID!
  description: String!
  price: Int!
  microservice: Microservice!
}

type ServiceListingSubscriptionPayload {
  mutation: MutationType!
  node: ServiceListing
  updatedFields: [String!]
  previousValues: ServiceListingPreviousValues
}

input ServiceListingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ServiceListingWhereInput
  AND: [ServiceListingSubscriptionWhereInput!]
  OR: [ServiceListingSubscriptionWhereInput!]
  NOT: [ServiceListingSubscriptionWhereInput!]
}

input ServiceListingUpdateDataInput {
  coach: UserUpdateOneRequiredInput
  description: String
  price: Int
  microservice: Microservice
  tags: ListingTagUpdateManyInput
  industry: ListingIndustryUpdateManyInput
}

input ServiceListingUpdateInput {
  coach: UserUpdateOneRequiredInput
  description: String
  price: Int
  microservice: Microservice
  tags: ListingTagUpdateManyInput
  industry: ListingIndustryUpdateManyInput
}

input ServiceListingUpdateManyMutationInput {
  description: String
  price: Int
  microservice: Microservice
}

input ServiceListingUpdateOneRequiredInput {
  create: ServiceListingCreateInput
  update: ServiceListingUpdateDataInput
  upsert: ServiceListingUpsertNestedInput
  connect: ServiceListingWhereUniqueInput
}

input ServiceListingUpsertNestedInput {
  update: ServiceListingUpdateDataInput!
  create: ServiceListingCreateInput!
}

input ServiceListingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  coach: UserWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  microservice: Microservice
  microservice_not: Microservice
  microservice_in: [Microservice!]
  microservice_not_in: [Microservice!]
  tags_every: ListingTagWhereInput
  tags_some: ListingTagWhereInput
  tags_none: ListingTagWhereInput
  industry_every: ListingIndustryWhereInput
  industry_some: ListingIndustryWhereInput
  industry_none: ListingIndustryWhereInput
  AND: [ServiceListingWhereInput!]
  OR: [ServiceListingWhereInput!]
  NOT: [ServiceListingWhereInput!]
}

input ServiceListingWhereUniqueInput {
  id: ID
}

type Subscription {
  coachFeedback(where: CoachFeedbackSubscriptionWhereInput): CoachFeedbackSubscriptionPayload
  feedbackEntry(where: FeedbackEntrySubscriptionWhereInput): FeedbackEntrySubscriptionPayload
  iQJobInfo(where: IQJobInfoSubscriptionWhereInput): IQJobInfoSubscriptionPayload
  job(where: JobSubscriptionWhereInput): JobSubscriptionPayload
  listingAvailability(where: ListingAvailabilitySubscriptionWhereInput): ListingAvailabilitySubscriptionPayload
  listingIndustry(where: ListingIndustrySubscriptionWhereInput): ListingIndustrySubscriptionPayload
  listingTag(where: ListingTagSubscriptionWhereInput): ListingTagSubscriptionPayload
  seekerReview(where: SeekerReviewSubscriptionWhereInput): SeekerReviewSubscriptionPayload
  seekerReviewResponse(where: SeekerReviewResponseSubscriptionWhereInput): SeekerReviewResponseSubscriptionPayload
  serviceListing(where: ServiceListingSubscriptionWhereInput): ServiceListingSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  stripeId: String
  stripeCusId: String
  password: String!
  email: String!
  first_name: String!
  last_name: String!
  city: String!
  state: String!
  bio: String
  image_url: String
  portfolio_url: String
  linkedin_url: String
  github_url: String
  personal_url: String
  blog_url: String
  twitter_url: String
  activated_stripe: Boolean
  chatActive: Boolean
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  stripeId: String
  stripeCusId: String
  password: String!
  email: String!
  first_name: String!
  last_name: String!
  city: String!
  state: String!
  bio: String
  image_url: String
  portfolio_url: String
  linkedin_url: String
  github_url: String
  personal_url: String
  blog_url: String
  twitter_url: String
  activated_stripe: Boolean
  chatActive: Boolean
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  stripeId_ASC
  stripeId_DESC
  stripeCusId_ASC
  stripeCusId_DESC
  password_ASC
  password_DESC
  email_ASC
  email_DESC
  first_name_ASC
  first_name_DESC
  last_name_ASC
  last_name_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  bio_ASC
  bio_DESC
  image_url_ASC
  image_url_DESC
  portfolio_url_ASC
  portfolio_url_DESC
  linkedin_url_ASC
  linkedin_url_DESC
  github_url_ASC
  github_url_DESC
  personal_url_ASC
  personal_url_DESC
  blog_url_ASC
  blog_url_DESC
  twitter_url_ASC
  twitter_url_DESC
  activated_stripe_ASC
  activated_stripe_DESC
  chatActive_ASC
  chatActive_DESC
}

type UserPreviousValues {
  id: ID!
  stripeId: String
  stripeCusId: String
  password: String!
  email: String!
  first_name: String!
  last_name: String!
  city: String!
  state: String!
  bio: String
  image_url: String
  portfolio_url: String
  linkedin_url: String
  github_url: String
  personal_url: String
  blog_url: String
  twitter_url: String
  activated_stripe: Boolean
  chatActive: Boolean
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  stripeId: String
  stripeCusId: String
  password: String
  email: String
  first_name: String
  last_name: String
  city: String
  state: String
  bio: String
  image_url: String
  portfolio_url: String
  linkedin_url: String
  github_url: String
  personal_url: String
  blog_url: String
  twitter_url: String
  activated_stripe: Boolean
  chatActive: Boolean
}

input UserUpdateInput {
  stripeId: String
  stripeCusId: String
  password: String
  email: String
  first_name: String
  last_name: String
  city: String
  state: String
  bio: String
  image_url: String
  portfolio_url: String
  linkedin_url: String
  github_url: String
  personal_url: String
  blog_url: String
  twitter_url: String
  activated_stripe: Boolean
  chatActive: Boolean
}

input UserUpdateManyMutationInput {
  stripeId: String
  stripeCusId: String
  password: String
  email: String
  first_name: String
  last_name: String
  city: String
  state: String
  bio: String
  image_url: String
  portfolio_url: String
  linkedin_url: String
  github_url: String
  personal_url: String
  blog_url: String
  twitter_url: String
  activated_stripe: Boolean
  chatActive: Boolean
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stripeId: String
  stripeId_not: String
  stripeId_in: [String!]
  stripeId_not_in: [String!]
  stripeId_lt: String
  stripeId_lte: String
  stripeId_gt: String
  stripeId_gte: String
  stripeId_contains: String
  stripeId_not_contains: String
  stripeId_starts_with: String
  stripeId_not_starts_with: String
  stripeId_ends_with: String
  stripeId_not_ends_with: String
  stripeCusId: String
  stripeCusId_not: String
  stripeCusId_in: [String!]
  stripeCusId_not_in: [String!]
  stripeCusId_lt: String
  stripeCusId_lte: String
  stripeCusId_gt: String
  stripeCusId_gte: String
  stripeCusId_contains: String
  stripeCusId_not_contains: String
  stripeCusId_starts_with: String
  stripeCusId_not_starts_with: String
  stripeCusId_ends_with: String
  stripeCusId_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  first_name: String
  first_name_not: String
  first_name_in: [String!]
  first_name_not_in: [String!]
  first_name_lt: String
  first_name_lte: String
  first_name_gt: String
  first_name_gte: String
  first_name_contains: String
  first_name_not_contains: String
  first_name_starts_with: String
  first_name_not_starts_with: String
  first_name_ends_with: String
  first_name_not_ends_with: String
  last_name: String
  last_name_not: String
  last_name_in: [String!]
  last_name_not_in: [String!]
  last_name_lt: String
  last_name_lte: String
  last_name_gt: String
  last_name_gte: String
  last_name_contains: String
  last_name_not_contains: String
  last_name_starts_with: String
  last_name_not_starts_with: String
  last_name_ends_with: String
  last_name_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  image_url: String
  image_url_not: String
  image_url_in: [String!]
  image_url_not_in: [String!]
  image_url_lt: String
  image_url_lte: String
  image_url_gt: String
  image_url_gte: String
  image_url_contains: String
  image_url_not_contains: String
  image_url_starts_with: String
  image_url_not_starts_with: String
  image_url_ends_with: String
  image_url_not_ends_with: String
  portfolio_url: String
  portfolio_url_not: String
  portfolio_url_in: [String!]
  portfolio_url_not_in: [String!]
  portfolio_url_lt: String
  portfolio_url_lte: String
  portfolio_url_gt: String
  portfolio_url_gte: String
  portfolio_url_contains: String
  portfolio_url_not_contains: String
  portfolio_url_starts_with: String
  portfolio_url_not_starts_with: String
  portfolio_url_ends_with: String
  portfolio_url_not_ends_with: String
  linkedin_url: String
  linkedin_url_not: String
  linkedin_url_in: [String!]
  linkedin_url_not_in: [String!]
  linkedin_url_lt: String
  linkedin_url_lte: String
  linkedin_url_gt: String
  linkedin_url_gte: String
  linkedin_url_contains: String
  linkedin_url_not_contains: String
  linkedin_url_starts_with: String
  linkedin_url_not_starts_with: String
  linkedin_url_ends_with: String
  linkedin_url_not_ends_with: String
  github_url: String
  github_url_not: String
  github_url_in: [String!]
  github_url_not_in: [String!]
  github_url_lt: String
  github_url_lte: String
  github_url_gt: String
  github_url_gte: String
  github_url_contains: String
  github_url_not_contains: String
  github_url_starts_with: String
  github_url_not_starts_with: String
  github_url_ends_with: String
  github_url_not_ends_with: String
  personal_url: String
  personal_url_not: String
  personal_url_in: [String!]
  personal_url_not_in: [String!]
  personal_url_lt: String
  personal_url_lte: String
  personal_url_gt: String
  personal_url_gte: String
  personal_url_contains: String
  personal_url_not_contains: String
  personal_url_starts_with: String
  personal_url_not_starts_with: String
  personal_url_ends_with: String
  personal_url_not_ends_with: String
  blog_url: String
  blog_url_not: String
  blog_url_in: [String!]
  blog_url_not_in: [String!]
  blog_url_lt: String
  blog_url_lte: String
  blog_url_gt: String
  blog_url_gte: String
  blog_url_contains: String
  blog_url_not_contains: String
  blog_url_starts_with: String
  blog_url_not_starts_with: String
  blog_url_ends_with: String
  blog_url_not_ends_with: String
  twitter_url: String
  twitter_url_not: String
  twitter_url_in: [String!]
  twitter_url_not_in: [String!]
  twitter_url_lt: String
  twitter_url_lte: String
  twitter_url_gt: String
  twitter_url_gte: String
  twitter_url_contains: String
  twitter_url_not_contains: String
  twitter_url_starts_with: String
  twitter_url_not_starts_with: String
  twitter_url_ends_with: String
  twitter_url_not_ends_with: String
  activated_stripe: Boolean
  activated_stripe_not: Boolean
  chatActive: Boolean
  chatActive_not: Boolean
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  stripeId: String
  stripeCusId: String
  email: String
}
`
      }
    